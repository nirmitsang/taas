import json
import logging
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import requests
from pymongo import MongoClient
from pymongo.errors import ConnectionFailure, OperationFailure
import pandas as pd
from datetime import datetime
import sys

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('validation.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class IssueType(Enum):
    TYPE_MISMATCH = "type_mismatch"
    PRECISION_LOSS = "precision_loss"
    DATE_FORMAT = "date_format_issue"
    NULL_HANDLING = "null_handling_issue"
    VALUE_MISMATCH = "value_mismatch"
    FIELD_MISSING = "field_missing"

@dataclass
class ValidationIssue:
    field_name: str
    issue_type: IssueType
    mongo_value: Any
    api_value: Any
    mongo_type: str
    api_type: str
    description: str
    severity: str = "medium"

@dataclass
class ValidationConfig:
    api_base_url: str
    bearer_token: str
    mongo_connection_string: str
    database_name: str
    collection_name: str
    field_mappings: Dict[str, str]  # api_field -> mongo_field
    sample_size: int = 100
    api_endpoint_template: str = "/api/data/{id}"  # Template with {id} placeholder

class DataFetcher:
    def __init__(self, config: ValidationConfig):
        self.config = config
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {config.bearer_token}',
            'Content-Type': 'application/json'
        })
        
        # MongoDB connection
        try:
            self.mongo_client = MongoClient(config.mongo_connection_string)
            self.db = self.mongo_client[config.database_name]
            self.collection = self.db[config.collection_name]
            # Test connection
            self.mongo_client.admin.command('ping')
            logger.info("MongoDB connection established successfully")
        except ConnectionFailure as e:
            logger.error(f"Failed to connect to MongoDB: {e}")
            raise

    def fetch_from_api(self, document_id: str) -> Optional[Dict[str, Any]]:
        """Fetch document from API using bearer token authentication"""
        try:
            endpoint = self.config.api_endpoint_template.format(id=document_id)
            url = f"{self.config.api_base_url.rstrip('/')}{endpoint}"
            
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            return response.json()
        except requests.exceptions.RequestException as e:
            logger.error(f"API request failed for ID {document_id}: {e}")
            return None
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse API response for ID {document_id}: {e}")
            return None

    def fetch_from_mongodb(self, document_id: str) -> Optional[Dict[str, Any]]:
        """Fetch document from MongoDB"""
        try:
            # Assume _id field, adjust if your ID field is different
            document = self.collection.find_one({"_id": document_id})
            return document
        except OperationFailure as e:
            logger.error(f"MongoDB query failed for ID {document_id}: {e}")
            return None

    def get_sample_document_ids(self) -> List[str]:
        """Get sample document IDs from MongoDB"""
        try:
            pipeline = [
                {"$sample": {"size": self.config.sample_size}},
                {"$project": {"_id": 1}}
            ]
            cursor = self.collection.aggregate(pipeline)
            return [str(doc["_id"]) for doc in cursor]
        except OperationFailure as e:
            logger.error(f"Failed to get sample IDs: {e}")
            return []

    def close(self):
        """Close connections"""
        if self.mongo_client:
            self.mongo_client.close()
        if self.session:
            self.session.close()

class TypeValidator:
    def __init__(self, config: ValidationConfig):
        self.config = config
        self.issues: List[ValidationIssue] = []

    def get_python_type_name(self, value: Any) -> str:
        """Get human-readable type name for Python values"""
        if value is None:
            return "null"
        elif isinstance(value, bool):
            return "boolean"
        elif isinstance(value, int):
            return "integer"
        elif isinstance(value, float):
            return "float"
        elif isinstance(value, str):
            return "string"
        elif isinstance(value, list):
            return "array"
        elif isinstance(value, dict):
            return "object"
        else:
            return str(type(value).__name__)

    def get_mongo_type_name(self, value: Any) -> str:
        """Get MongoDB/BSON type name"""
        from bson import ObjectId
        from datetime import datetime
        
        if value is None:
            return "null"
        elif isinstance(value, bool):
            return "boolean"
        elif isinstance(value, int):
            # Check if it's within int32 range
            if -2147483648 <= value <= 2147483647:
                return "int32"
            else:
                return "int64"
        elif isinstance(value, float):
            return "double"
        elif isinstance(value, str):
            return "string"
        elif isinstance(value, list):
            return "array"
        elif isinstance(value, dict):
            return "object"
        elif isinstance(value, ObjectId):
            return "objectId"
        elif isinstance(value, datetime):
            return "date"
        else:
            return str(type(value).__name__)

    def check_java21_compatibility(self, mongo_value: Any, api_value: Any, field_name: str) -> List[ValidationIssue]:
        """Check for Java 21 specific compatibility issues"""
        issues = []
        
        # Numeric precision checks
        if isinstance(mongo_value, (int, float)) and isinstance(api_value, (int, float)):
            if abs(mongo_value - api_value) > 1e-10:  # Floating point tolerance
                issues.append(ValidationIssue(
                    field_name=field_name,
                    issue_type=IssueType.PRECISION_LOSS,
                    mongo_value=mongo_value,
                    api_value=api_value,
                    mongo_type=self.get_mongo_type_name(mongo_value),
                    api_type=self.get_python_type_name(api_value),
                    description=f"Potential precision loss: {mongo_value} != {api_value}",
                    severity="high"
                ))

        # Integer overflow checks for Java 21
        if isinstance(mongo_value, int) and isinstance(api_value, (int, float)):
            # Check if MongoDB int64 value fits in Java int32
            if mongo_value > 2147483647 or mongo_value < -2147483648:
                if isinstance(api_value, int) and abs(api_value) <= 2147483647:
                    issues.append(ValidationIssue(
                        field_name=field_name,
                        issue_type=IssueType.PRECISION_LOSS,
                        mongo_value=mongo_value,
                        api_value=api_value,
                        mongo_type=self.get_mongo_type_name(mongo_value),
                        api_type=self.get_python_type_name(api_value),
                        description="Potential integer overflow in Java 21 strict mode",
                        severity="high"
                    ))

        # Null handling strictness
        if mongo_value is None and api_value is not None:
            issues.append(ValidationIssue(
                field_name=field_name,
                issue_type=IssueType.NULL_HANDLING,
                mongo_value=mongo_value,
                api_value=api_value,
                mongo_type="null",
                api_type=self.get_python_type_name(api_value),
                description="MongoDB null converted to non-null in API response",
                severity="medium"
            ))

        # Date format issues
        if isinstance(mongo_value, datetime) and isinstance(api_value, str):
            try:
                # Try parsing the API date string
                datetime.fromisoformat(api_value.replace('Z', '+00:00'))
            except ValueError:
                issues.append(ValidationIssue(
                    field_name=field_name,
                    issue_type=IssueType.DATE_FORMAT,
                    mongo_value=mongo_value,
                    api_value=api_value,
                    mongo_type="date",
                    api_type="string",
                    description="Date format may not be compatible with Java 21 strict parsing",
                    severity="medium"
                ))

        return issues

    def validate_document_pair(self, api_doc: Dict[str, Any], mongo_doc: Dict[str, Any], doc_id: str) -> List[ValidationIssue]:
        """Validate a pair of documents from API and MongoDB"""
        issues = []
        
        for api_field, mongo_field in self.config.field_mappings.items():
            # Check if fields exist
            api_value = api_doc.get(api_field)
            mongo_value = mongo_doc.get(mongo_field)
            
            if api_field not in api_doc:
                issues.append(ValidationIssue(
                    field_name=api_field,
                    issue_type=IssueType.FIELD_MISSING,
                    mongo_value=mongo_value,
                    api_value=None,
                    mongo_type=self.get_mongo_type_name(mongo_value),
                    api_type="missing",
                    description=f"Field {api_field} missing from API response",
                    severity="high"
                ))
                continue

            if mongo_field not in mongo_doc:
                issues.append(ValidationIssue(
                    field_name=api_field,
                    issue_type=IssueType.FIELD_MISSING,
                    mongo_value=None,
                    api_value=api_value,
                    mongo_type="missing",
                    api_type=self.get_python_type_name(api_value),
                    description=f"Field {mongo_field} missing from MongoDB document",
                    severity="high"
                ))
                continue

            # Type comparison
            mongo_type = self.get_mongo_type_name(mongo_value)
            api_type = self.get_python_type_name(api_value)
            
            # Basic type mismatch check
            if not self.types_compatible(mongo_type, api_type):
                issues.append(ValidationIssue(
                    field_name=api_field,
                    issue_type=IssueType.TYPE_MISMATCH,
                    mongo_value=mongo_value,
                    api_value=api_value,
                    mongo_type=mongo_type,
                    api_type=api_type,
                    description=f"Type mismatch: MongoDB({mongo_type}) vs API({api_type})",
                    severity="high"
                ))

            # Java 21 specific compatibility checks
            java21_issues = self.check_java21_compatibility(mongo_value, api_value, api_field)
            issues.extend(java21_issues)

        return issues

    def types_compatible(self, mongo_type: str, api_type: str) -> bool:
        """Check if MongoDB and API types are compatible"""
        # Define compatible type mappings
        compatible_mappings = {
            "int32": ["integer", "float"],
            "int64": ["integer", "float"],
            "double": ["float", "integer"],
            "string": ["string"],
            "boolean": ["boolean"],
            "date": ["string"],  # Dates often serialized as ISO strings
            "objectId": ["string"],  # ObjectIds serialized as strings
            "array": ["array"],
            "object": ["object"],
            "null": ["null"]
        }
        
        return api_type in compatible_mappings.get(mongo_type, [])

class ValidationReporter:
    def __init__(self):
        self.issues: List[ValidationIssue] = []

    def add_issues(self, issues: List[ValidationIssue]):
        """Add validation issues to the report"""
        self.issues.extend(issues)

    def generate_summary_report(self) -> Dict[str, Any]:
        """Generate summary statistics"""
        total_issues = len(self.issues)
        
        by_type = {}
        by_severity = {}
        by_field = {}
        
        for issue in self.issues:
            # Count by issue type
            issue_type = issue.issue_type.value
            by_type[issue_type] = by_type.get(issue_type, 0) + 1
            
            # Count by severity
            by_severity[issue.severity] = by_severity.get(issue.severity, 0) + 1
            
            # Count by field
            by_field[issue.field_name] = by_field.get(issue.field_name, 0) + 1
        
        return {
            "total_issues": total_issues,
            "by_type": by_type,
            "by_severity": by_severity,
            "by_field": by_field,
            "generated_at": datetime.now().isoformat()
        }

    def export_detailed_report(self, filename: str = "validation_report.xlsx"):
        """Export detailed report to Excel"""
        if not self.issues:
            logger.info("No issues found to report")
            return
        
        # Convert issues to DataFrame
        data = []
        for issue in self.issues:
            data.append({
                "Field Name": issue.field_name,
                "Issue Type": issue.issue_type.value,
                "Severity": issue.severity,
                "MongoDB Value": str(issue.mongo_value)[:100],  # Truncate long values
                "API Value": str(issue.api_value)[:100],
                "MongoDB Type": issue.mongo_type,
                "API Type": issue.api_type,
                "Description": issue.description
            })
        
        df = pd.DataFrame(data)
        
        # Export to Excel with multiple sheets
        with pd.ExcelWriter(filename, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='All Issues', index=False)
            
            # Separate sheets by issue type
            for issue_type in df['Issue Type'].unique():
                filtered_df = df[df['Issue Type'] == issue_type]
                sheet_name = issue_type.replace('_', ' ').title()[:31]  # Excel sheet name limit
                filtered_df.to_excel(writer, sheet_name=sheet_name, index=False)
        
        logger.info(f"Detailed report exported to {filename}")

    def print_summary(self):
        """Print summary to console"""
        summary = self.generate_summary_report()
        
        print("\n" + "="*50)
        print("VALIDATION SUMMARY REPORT")
        print("="*50)
        print(f"Total Issues Found: {summary['total_issues']}")
        
        if summary['total_issues'] > 0:
            print(f"\nBy Severity:")
            for severity, count in summary['by_severity'].items():
                print(f"  {severity.upper()}: {count}")
            
            print(f"\nBy Issue Type:")
            for issue_type, count in summary['by_type'].items():
                print(f"  {issue_type.replace('_', ' ').title()}: {count}")
            
            print(f"\nTop 10 Problematic Fields:")
            sorted_fields = sorted(summary['by_field'].items(), key=lambda x: x[1], reverse=True)
            for field, count in sorted_fields[:10]:
                print(f"  {field}: {count} issues")

def main():
    """Main execution function"""
    # Example configuration - replace with your actual values
    config = ValidationConfig(
        api_base_url="https://your-api-domain.com",
        bearer_token="your-bearer-token-here",
        mongo_connection_string="mongodb://localhost:27017/",
        database_name="your_database",
        collection_name="your_collection",
        field_mappings={
            # API field -> MongoDB field mappings
            "id": "_id",
            "name": "name",
            "email": "email",
            "age": "age",
            "created_at": "createdAt",
            "is_active": "isActive"
        },
        sample_size=50,
        api_endpoint_template="/api/users/{id}"  # Adjust endpoint template
    )
    
    logger.info("Starting validation process...")
    
    # Initialize components
    fetcher = DataFetcher(config)
    validator = TypeValidator(config)
    reporter = ValidationReporter()
    
    try:
        # Get sample document IDs
        logger.info("Fetching sample document IDs...")
        sample_ids = fetcher.get_sample_document_ids()
        
        if not sample_ids:
            logger.error("No sample IDs found. Exiting.")
            return
        
        logger.info(f"Processing {len(sample_ids)} documents...")
        
        # Process each document
        processed_count = 0
        for doc_id in sample_ids:
            logger.info(f"Processing document {doc_id} ({processed_count + 1}/{len(sample_ids)})")
            
            # Fetch from both sources
            api_doc = fetcher.fetch_from_api(doc_id)
            mongo_doc = fetcher.fetch_from_mongodb(doc_id)
            
            if api_doc is None:
                logger.warning(f"Skipping {doc_id}: API fetch failed")
                continue
                
            if mongo_doc is None:
                logger.warning(f"Skipping {doc_id}: MongoDB fetch failed")
                continue
            
            # Validate document pair
            issues = validator.validate_document_pair(api_doc, mongo_doc, doc_id)
            reporter.add_issues(issues)
            
            processed_count += 1
            
            # Progress update
            if processed_count % 10 == 0:
                logger.info(f"Processed {processed_count} documents so far...")
        
        logger.info("Validation complete. Generating reports...")
        
        # Generate reports
        reporter.print_summary()
        reporter.export_detailed_report()
        
        # Save summary as JSON
        summary = reporter.generate_summary_report()
        with open('validation_summary.json', 'w') as f:
            json.dump(summary, f, indent=2)
        
        logger.info("Reports generated successfully!")
        
    except Exception as e:
        logger.error(f"Validation process failed: {e}")
        raise
    finally:
        fetcher.close()

if __name__ == "__main__":
    main()
